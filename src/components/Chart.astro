---
const { signalParamsProp } = Astro.props;

type SignalParams = {
  a: number;
  b: number;
  signalShape: string;
  amplitude: number;
  frequency: number;
  phase: number;
  interval: number;
  freqrange: number;
};

// turns all string values to numbers
const signalParams = Object.keys(signalParamsProp).reduce((newObj, key) => {
    const parsedValue = parseInt(signalParamsProp[key], 10); // Radix specified!
    newObj[key] = isNaN(parsedValue) ? signalParamsProp[key] : parsedValue;
    return newObj;
}, {}) as SignalParams;


function formatLegend(signalParams: SignalParams) {
	const { a, b, signalShape, amplitude, frequency, phase, interval, freqrange } = signalParams;
	
	const inputFormatters = {
		square: `f(t) = A â‹… Î (t / T) = ${amplitude} â‹… Î (t / ${frequency})`,
		triangle: `f(t) = A â‹… Î›(t / 2T) = ${amplitude} â‹… Î›(t / ${frequency})`,
		sinc: `f(t) = A â‹… fâ‚€ â‹… sinc(fâ‚€ â‹… t) = ${amplitude} â‹… sinc(t / ${frequency})`,
		sin: `f(t) = A â‹… sin(2Ï€ â‹… fâ‚€ â‹… t + Ï•) = ${amplitude} â‹… sin(2Ï€ â‹… ${frequency} â‹… t + ${phase})`,
		cos: `f(t) = A â‹… cos(2Ï€ â‹… fâ‚€ â‹… t + Ï•) = ${amplitude} â‹… cos(2Ï€ â‹… ${frequency} â‹… t + ${phase})`,
		exp: `f(t) = ${amplitude}â‹…exp(t)`
	};

	const outputFormatters = {
		square: `re(FFT(f(t))) = A â‹… T â‹… sinc(T â‹… f) = ${amplitude} â‹… ${frequency} â‹… sinc(${frequency} â‹… f)`,
		triangle: `re(FFT(f(t))) = A â‹… T â‹… sincÂ²(T â‹… f) = ${amplitude} â‹… ${frequency} â‹… sincÂ²(${frequency} â‹… f)`,
		sinc: `re(FFT(f(t))) = A â‹… Î (f / fâ‚€) = ${amplitude} â‹… Î (f / ${frequency})`,
		cos: `re(FFT(f(t))) = A â‹… Â½(ğ›¿(f - fâ‚€) + ğ›¿(f + fâ‚€)) = ${amplitude} â‹… Â½(ğ›¿(f - ${frequency}) + ğ›¿(f + ${frequency}))`,
	};

	const inputSymbolName = inputFormatters[signalShape]
	? inputFormatters[signalShape]
	: `f(t)`;

	const outputSymbolName = outputFormatters[signalShape]
	? outputFormatters[signalShape]
	: `re(FFT(f(t)))`;


	return {
		inputSymbolName,
		outputSymbolName,
	};
}

const { inputSymbolName, outputSymbolName } = formatLegend(signalParams);
---

<div id="chart-root">
	<div id="container1" class="my-10 flex mx-auto w-[800px] h-[300px] justify-center relative">
		<div id="inputLegend" class="absolute left-0 transform -top-2 z-10 text-sm font-sans font-light text-white"></div>
	</div>
	<div id="container2" class="flex mx-auto w-[800px] h-[300px] justify-center relative">
		<div id="outputLegend" class="absolute left-0 transform -top-2 z-10 text-sm font-sans font-light text-white"></div>
	</div>
</div>


<script define:vars={{ signalParamsProp }}>
import { createChart } from 'lightweight-charts';
import { fetchSignal } from '../scripts/SignalHandler.astro'

const chartRoot = document.getElementById('chart-root');
const signalParams = JSON.parse(chartRoot.dataset.params);
const loadingEl = document.getElementById('loading');

function formatLegend(signalParams) {
	const { a, b, signalShape, amplitude, frequency, phase, interval, freqrange } = signalParams;
	
	const inputFormatters = {
		square: `f(t) = A â‹… Î (t / T) = ${amplitude} â‹… Î (t / ${frequency})`,
		triangle: `f(t) = A â‹… Î›(t / 2T) = ${amplitude} â‹… Î›(t / ${frequency})`,
		sinc: `f(t) = A â‹… fâ‚€ â‹… sinc(fâ‚€ â‹… t) = ${amplitude} â‹… sinc(t / ${frequency})`,
		sin: `f(t) = A â‹… sin(2Ï€ â‹… fâ‚€ â‹… t + Ï•) = ${amplitude} â‹… sin(2Ï€ â‹… ${frequency} â‹… t + ${phase})`,
		cos: `f(t) = A â‹… cos(2Ï€ â‹… fâ‚€ â‹… t + Ï•) = ${amplitude} â‹… cos(2Ï€ â‹… ${frequency} â‹… t + ${phase})`,
		exp: `f(t) = ${amplitude}â‹…exp(t)`
	};

	const outputFormatters = {
		square: `re(FFT(f(t))) = A â‹… T â‹… sinc(T â‹… f) = ${amplitude} â‹… ${frequency} â‹… sinc(${frequency} â‹… f)`,
		triangle: `re(FFT(f(t))) = A â‹… T â‹… sincÂ²(T â‹… f) = ${amplitude} â‹… ${frequency} â‹… sincÂ²(${frequency} â‹… f)`,
		sinc: `re(FFT(f(t))) = A â‹… Î (f / fâ‚€) = ${amplitude} â‹… Î (f / ${frequency})`,
		cos: `re(FFT(f(t))) = A â‹… Â½(ğ›¿(f - fâ‚€) + ğ›¿(f + fâ‚€)) = ${amplitude} â‹… Â½(ğ›¿(f - ${frequency}) + ğ›¿(f + ${frequency}))`,
	};

	const inputSymbolName = inputFormatters[signalShape]
	? inputFormatters[signalShape]
	: `f(t)`;

	const outputSymbolName = outputFormatters[signalShape]
	? outputFormatters[signalShape]
	: `re(FFT(f(t)))`;


	return {
		inputSymbolName,
		outputSymbolName,
	};
}

let { inputSymbolName, outputSymbolName } = formatLegend(signalParams);

const chartOptions = {
  width: 800,
  height: 300,
	layout: {
		textColor: 'white',
		background: { color: '#13151a' },
		attributionLogo: false,
	},
	localization: {
    timeFormatter: time => time.toString(), // use numeric formatting
  },
};
const optionsToApply = {
	autoScale : true,
	rightPriceScale: {
		scaleMargins: {
			top: 0.4, // leave some space for the legend
			bottom: 0.15,
		},
	},
	crosshair: {
		// hide the horizontal crosshair line
		horzLine: {
			visible: false,
			labelVisible: false,
		},
	},
	// hide the grid lines
	grid: {
		vertLines: {
			visible: false,
		},
		horzLines: {
			visible: false,
		},
	},
}

const inputChart = createChart(document.getElementById('container1'), chartOptions);
inputChart.applyOptions(optionsToApply)

const inputAreaSeries = inputChart.addAreaSeries({
	topColor: '#d5b8f9',
	bottomColor: 'rgba(213, 184, 249, 0.5)',
	lineColor: '#d5b8f9',
	lineWidth: 2,
	priceLineVisible: false,
});

const outputChart = createChart(document.getElementById('container2'), chartOptions);
outputChart.applyOptions(optionsToApply);

const outputAreaSeries = outputChart.addAreaSeries({
	topColor: '#d5b8f9',
	bottomColor: 'rgba(143, 67, 234, 0.33)',
	lineColor: '#d5b8f9',
	lineWidth: 2,
	priceLineVisible: false,
});

const inputLegend = document.getElementById('inputLegend')
const outputLegend = document.getElementById('outputLegend')


const getLastBar = series => {
	const lastIndex = series.dataByIndex(Infinity, -1);
	return series.dataByIndex(lastIndex);
};
const formatPrice = price => (Math.round(price * 100) / 100).toFixed(2);

const setTooltipHtml = (legend, name, time, value) => {
	legend.innerHTML = `
		<div class="text-lg my-0">${name}</div>
    	<div class="text-base my-0">${value}</div>
    	<div class="text-sm my-0">${time}</div>
	`;
};

const inputUpdateLegend = param => {
	const validCrosshairPoint = !(
		param === undefined || param.time === undefined || param.point.x < 0 || param.point.y < 0
	);
	const bar = validCrosshairPoint ? param.seriesData.get(inputAreaSeries) : getLastBar(inputAreaSeries);
	// time is in the same format that you supplied to the setData method,
	// which in this case is YYYY-MM-DD
	const time = bar.time;
	const price = bar.value !== undefined ? bar.value : bar.close;
	const formattedPrice = formatPrice(price);
	setTooltipHtml(inputLegend, inputSymbolName, time, formattedPrice);
};

const outputUpdateLegend = param => {
	const validCrosshairPoint = !(
		param === undefined || param.time === undefined || param.point.x < 0 || param.point.y < 0
	);
	const bar = validCrosshairPoint ? param.seriesData.get(outputAreaSeries) : getLastBar(outputAreaSeries);
	// time is in the same format that you supplied to the setData method,
	// which in this case is YYYY-MM-DD
	const time = bar.time;
	const price = bar.value !== undefined ? bar.value : bar.close;
	const formattedPrice = formatPrice(price);
	setTooltipHtml(outputLegend, outputSymbolName, time, formattedPrice);
};


inputChart.subscribeCrosshairMove(inputUpdateLegend);
outputChart.subscribeCrosshairMove(outputUpdateLegend);

inputUpdateLegend(undefined);
outputUpdateLegend(undefined);

async function getDataFromServer(signalParams) {
	const inputSignal = [];
	const outputSignal = [];

	const data = await fetchSignal(signalParams);
	data.forEach((row) => {
		outputSignal.push({
			time: parseFloat(row.Freq),
			value: parseFloat(row["re(FFT)"]),
		});
		inputSignal.push({
			time: parseFloat(row.input),
			value: parseFloat(row["re(signal)"]),
		});
	});

    const outputSignalSliced = outputSignal.filter(point =>
        point.time >= -signalParams.freqrange
					&& point.time <= signalParams.freqrange
    );

  	return {
        inputSignal,
        outputSignal,
		outputSignalSliced
	};
}

try {
	const { inputSignal, outputSignalSliced } = await getDataFromServer(signalParams);
	
	inputAreaSeries.setData(inputSignal);
	outputAreaSeries.setData(outputSignalSliced);
	
	inputUpdateLegend(undefined);
	outputUpdateLegend(undefined);
	
	inputChart.timeScale().fitContent();
	outputChart.timeScale().fitContent();
	
	// Hide loading after data is loaded
	loadingEl.style.display = 'none';
} catch (error) {
	console.error("Error loading initial chart data:", error);
	loadingEl.textContent = "Error loading data. Please try again.";
}


async function updateChartData(signalParams) {
	// Show loading
	loadingEl.style.display = 'block';

	// Update legend symbols based on new parameters
	const { inputSymbolName, outputSymbolName } = formatLegend(signalParams);

	console.log("Updating chart data");
    const { inputSignal, outputSignalSliced } = await getDataFromServer(signalParams);

	inputAreaSeries.setData(inputSignal);
    outputAreaSeries.setData(outputSignalSliced);
    
	inputUpdateLegend(undefined);
    outputUpdateLegend(undefined);

	inputChart.timeScale().fitContent();
	outputChart.timeScale().fitContent();
}

// Expose updateChartData to global scope
window.updateChartData = updateChartData;

inputChart.timeScale().applyOptions({
	minBarSpacing: 0.1,
	fixLeftEdge: true,
	fixRightEdge: true,
	timeVisible: true,
	tickMarkFormatter: time => time.toString(),
})

outputChart.timeScale().applyOptions({
	minBarSpacing: 0.1,
	fixLeftEdge: true,
	fixRightEdge: true,
	timeVisible: true,
	tickMarkFormatter: time => time.toString(),
})

inputChart.timeScale().fitContent();
outputChart.timeScale().fitContent();
</script>
